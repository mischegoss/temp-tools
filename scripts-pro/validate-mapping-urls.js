/**
 * Mapping URL Validator
 * Tests URLs from mapping files (generated by mapping-generator.js) against docs.resolve.io
 *
 * Usage:
 *   1. Set MAPPING_FILE_NAME below to test specific file
 *   2. Or use command line: node validate-mapping-urls.js --file=filename.json
 *   3. Or test all: node validate-mapping-urls.js --all
 */

const https = require('https')
const fs = require('fs').promises
const path = require('path')

// =============================================================================
// ğŸ“ EDIT THIS TO TEST A SPECIFIC MAPPING FILE
// =============================================================================
const MAPPING_FILE_NAME = 'pro-mapping-7.9.json' // ğŸ‘ˆ Change this to test different files
// Examples:
// const MAPPING_FILE_NAME = 'express-mapping-SaaS.json'
// const MAPPING_FILE_NAME = 'actions-mapping-latest.json'
// const MAPPING_FILE_NAME = 'insights-mapping-11.0.json'
// Set to null to use command line options instead
// =============================================================================

// Configuration
const LIVE_SITE_BASE = 'https://docs.resolve.io'
const DEFAULT_SAMPLE_SIZE = 25
const TIMEOUT_MS = 10000
const CONCURRENT_REQUESTS = 3 // Conservative for mapping validation
const MAPPINGS_DIR = path.join('src', 'plugins')

// Parse command line arguments
const args = process.argv.slice(2)
const options = {
  all: args.includes('--all') && !MAPPING_FILE_NAME, // Only use --all if no file specified
  file:
    MAPPING_FILE_NAME ||
    args.find(arg => arg.startsWith('--file='))?.split('=')[1], // Priority to variable
  product: args.find(arg => arg.startsWith('--product='))?.split('=')[1],
  sample:
    parseInt(args.find(arg => arg.startsWith('--sample='))?.split('=')[1]) ||
    DEFAULT_SAMPLE_SIZE,
  verbose: args.includes('--verbose') || args.includes('-v'),
}

async function findMappingFiles() {
  try {
    const files = await fs.readdir(MAPPINGS_DIR)
    return files.filter(
      file => file.includes('-mapping-') && file.endsWith('.json'),
    )
  } catch (error) {
    console.error(`âŒ Error reading mappings directory: ${error.message}`)
    return []
  }
}

function filterMappingFiles(allFiles, options) {
  let filesToTest = [...allFiles]

  // Filter by specific file (priority to variable)
  if (options.file) {
    const targetFile = options.file
    if (allFiles.includes(targetFile)) {
      return [targetFile]
    } else {
      console.log(`âš ï¸  File "${targetFile}" not found`)
      return []
    }
  }

  // Filter by product
  if (options.product) {
    filesToTest = filesToTest.filter(file =>
      file.startsWith(`${options.product}-mapping-`),
    )
  }

  // If not --all and no specific criteria, default to first file
  if (!options.all && !options.product && !options.file) {
    return filesToTest.slice(0, 1)
  }

  return filesToTest
}

async function validateSingleMappingFile(fileName, options) {
  const filePath = path.join(MAPPINGS_DIR, fileName)

  try {
    // Load mapping file
    const fileContent = await fs.readFile(filePath, 'utf8')
    const mappingData = JSON.parse(fileContent)

    // Extract URLs to test
    const urlsToTest = extractUrlsFromMapping(mappingData, options)

    console.log(
      `ğŸ“Š Loaded mapping file: ${
        Object.keys(mappingData).length
      } total entries`,
    )
    console.log(
      `ğŸ¯ Testing ${urlsToTest.length} URLs against ${LIVE_SITE_BASE}`,
    )
    console.log(
      `âš™ï¸  Sample size: ${options.sample}, Concurrent requests: ${CONCURRENT_REQUESTS}`,
    )

    // Test URLs in batches
    const results = await testUrlsInBatches(
      urlsToTest,
      CONCURRENT_REQUESTS,
      fileName,
      options,
    )

    // Generate file-specific report
    generateFileReport(
      results,
      fileName,
      urlsToTest.length,
      Object.keys(mappingData).length,
    )

    return {
      ...results,
      totalTested: urlsToTest.length,
      totalMappings: Object.keys(mappingData).length,
    }
  } catch (error) {
    console.error(`âŒ Error validating ${fileName}: ${error.message}`)
    return {
      success: [],
      failed: [],
      errors: [],
      totalTested: 0,
      totalMappings: 0,
    }
  }
}

function extractUrlsFromMapping(mappingData, options) {
  const urls = []

  // Extract all URLs from mapping (skip metadata entries)
  Object.entries(mappingData).forEach(([key, url]) => {
    if (key.startsWith('_')) return // Skip metadata

    urls.push({
      key,
      url,
      source: 'mapping',
    })
  })

  // Sample if not testing all
  if (!options.all && urls.length > options.sample) {
    // Shuffle and sample
    shuffleArray(urls)
    return urls.slice(0, options.sample)
  }

  return urls
}

async function testUrlsInBatches(urls, batchSize, fileName, options) {
  const results = {
    success: [],
    failed: [],
    errors: [],
  }

  console.log(`\nğŸ“¦ Testing ${urls.length} URLs in batches of ${batchSize}`)

  // Process URLs in batches
  for (let i = 0; i < urls.length; i += batchSize) {
    const batch = urls.slice(i, i + batchSize)

    console.log(
      `\nğŸ“¦ Batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(
        urls.length / batchSize,
      )} (${batch.length} URLs)`,
    )

    // Test batch concurrently
    const batchPromises = batch.map(urlInfo => testSingleUrl(urlInfo))
    const batchResults = await Promise.allSettled(batchPromises)

    // Process batch results
    batchResults.forEach((result, index) => {
      const urlInfo = batch[index]

      if (result.status === 'fulfilled') {
        const testResult = result.value

        if (testResult.success) {
          results.success.push({ ...urlInfo, ...testResult })
          console.log(`  âœ… ${testResult.status} ${urlInfo.url}`)
        } else {
          results.failed.push({ ...urlInfo, ...testResult })
          console.log(`  âŒ ${testResult.status} ${urlInfo.url}`)
          if (options.verbose) {
            console.log(`     Key: "${urlInfo.key}"`)
          }
        }
      } else {
        results.errors.push({ ...urlInfo, error: result.reason.message })
        console.log(`  ğŸ’¥ ERROR ${urlInfo.url} - ${result.reason.message}`)
      }
    })

    // Show progress
    const totalTested = i + batch.length
    const successRate = ((results.success.length / totalTested) * 100).toFixed(
      1,
    )
    console.log(
      `  ğŸ“Š Progress: ${totalTested}/${urls.length} (${successRate}% success)`,
    )

    // Brief pause between batches
    if (i + batchSize < urls.length) {
      await new Promise(resolve => setTimeout(resolve, 1000))
    }
  }

  return results
}

function testSingleUrl(urlInfo) {
  return new Promise(resolve => {
    const fullUrl = LIVE_SITE_BASE + urlInfo.url

    // Parse URL
    const urlObj = new URL(fullUrl)

    const options = {
      hostname: urlObj.hostname,
      port: urlObj.port || 443,
      path: urlObj.pathname + urlObj.search,
      method: 'HEAD', // Use HEAD to avoid downloading content
      timeout: TIMEOUT_MS,
      headers: {
        'User-Agent': 'Mapping-URL-Validator/1.0 (docs validation script)',
      },
    }

    const req = https.request(options, res => {
      const success = res.statusCode >= 200 && res.statusCode < 400

      resolve({
        success,
        status: res.statusCode,
        fullUrl,
        redirected: res.statusCode >= 300 && res.statusCode < 400,
        location: res.headers.location || null,
      })
    })

    req.on('error', error => {
      resolve({
        success: false,
        status: 'ERROR',
        fullUrl,
        error: error.message,
      })
    })

    req.on('timeout', () => {
      req.destroy()
      resolve({
        success: false,
        status: 'TIMEOUT',
        fullUrl,
        error: `Request timed out after ${TIMEOUT_MS}ms`,
      })
    })

    req.end()
  })
}

function generateFileReport(results, fileName, totalTested, totalMappings) {
  const successCount = results.success.length
  const failedCount = results.failed.length
  const errorCount = results.errors.length
  const successRate = ((successCount / totalTested) * 100).toFixed(1)

  console.log(`\nğŸ“Š Results for ${fileName}:`)
  console.log(
    `   âœ… Successful: ${successCount}/${totalTested} (${successRate}%)`,
  )
  console.log(`   âŒ Failed: ${failedCount}/${totalTested}`)
  console.log(`   ğŸ’¥ Errors: ${errorCount}/${totalTested}`)
  console.log(`   ğŸ“„ Total mappings in file: ${totalMappings}`)

  // Show some failed URLs for debugging
  if (failedCount > 0) {
    console.log(`\nâŒ Failed URLs (first 5):`)
    results.failed.slice(0, 5).forEach(result => {
      console.log(`   ${result.status} ${result.fullUrl}`)
      console.log(`      Key: "${result.key}"`)
    })

    if (failedCount > 5) {
      console.log(`   ... and ${failedCount - 5} more`)
    }
  }
}

function generateOverallReport(allResults, filesToTest) {
  console.log('\n' + '='.repeat(80))
  console.log('ğŸ¯ OVERALL MAPPING VALIDATION REPORT')
  console.log('='.repeat(80))

  const successCount = allResults.success.length
  const failedCount = allResults.failed.length
  const errorCount = allResults.errors.length
  const totalTested = allResults.totalTested
  const successRate =
    totalTested > 0 ? ((successCount / totalTested) * 100).toFixed(1) : 0

  console.log(`ğŸ“Š Overall Results:`)
  console.log(
    `   âœ… Successful: ${successCount}/${totalTested} (${successRate}%)`,
  )
  console.log(`   âŒ Failed: ${failedCount}/${totalTested}`)
  console.log(`   ğŸ’¥ Errors: ${errorCount}/${totalTested}`)
  console.log(`   ğŸ“ Files tested: ${filesToTest.length}`)
  console.log(`   ğŸ“„ Total mappings: ${allResults.totalMappings}`)

  console.log(`\nğŸ’¡ Recommendations:`)
  if (successRate >= 90) {
    console.log(`   ğŸ‰ Excellent! Mapping URLs are working well`)
    console.log(
      `   âœ¨ ${successRate}% success rate indicates good URL generation`,
    )
  } else if (successRate >= 70) {
    console.log(`   âš ï¸  Good but some issues - check failed URLs`)
    console.log(
      `   ğŸ” ${failedCount} URLs failing, may need mapping adjustments`,
    )
  } else {
    console.log(`   ğŸ”§ Poor success rate suggests mapping issues`)
    console.log(`   ğŸ“‹ Check mapping generator URL logic`)
    console.log(`   ğŸ” Compare with working URLs from site`)
  }

  if (failedCount > 0) {
    console.log(`   ğŸ“ Common failure reasons:`)
    console.log(`      - Mapping file contains old/incorrect URLs`)
    console.log(`      - Files exist in repo but not deployed`)
    console.log(`      - URL generation logic differences`)
  }

  console.log(`\nğŸš€ To improve results:`)
  console.log(`   ğŸ“ Regenerate mappings: node mapping-generator.js`)
  console.log(`   ğŸ” Check specific file: Edit MAPPING_FILE_NAME variable`)
  console.log(
    `   ğŸ§ª Test with verbose: node validate-mapping-urls.js --verbose`,
  )

  console.log('\n' + '='.repeat(80))

  // Exit with error code if success rate is too low
  if (successRate < 50) {
    console.error('âŒ Success rate too low - likely mapping generation issues')
    process.exit(1)
  }
}

// Utility function to shuffle array
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[array[i], array[j]] = [array[j], array[i]]
  }
}

async function validateMappingUrls() {
  console.log('ğŸ” Mapping URL Validator')
  console.log('='.repeat(50))

  try {
    // Step 1: Find mapping files to test
    const mappingFiles = await findMappingFiles()

    if (mappingFiles.length === 0) {
      console.log('âŒ No mapping files found in src/plugins/')
      console.log('ğŸ’¡ Run mapping generator first: node mapping-generator.js')
      return
    }

    // Step 2: Filter files based on options
    const filesToTest = filterMappingFiles(mappingFiles, options)

    if (filesToTest.length === 0) {
      console.log('âŒ No mapping files match your criteria')
      return
    }

    console.log(
      `ğŸ“ Found ${mappingFiles.length} mapping files, testing ${filesToTest.length}:`,
    )
    filesToTest.forEach(file => console.log(`   ğŸ“„ ${file}`))

    // Step 3: Load and validate each mapping file
    const allResults = {
      success: [],
      failed: [],
      errors: [],
      totalTested: 0,
      totalMappings: 0,
    }

    for (const fileName of filesToTest) {
      console.log(`\n${'='.repeat(60)}`)
      console.log(`ğŸ§ª Testing: ${fileName}`)
      console.log(`${'='.repeat(60)}`)

      const fileResults = await validateSingleMappingFile(fileName, options)

      // Combine results
      allResults.success.push(...fileResults.success)
      allResults.failed.push(...fileResults.failed)
      allResults.errors.push(...fileResults.errors)
      allResults.totalTested += fileResults.totalTested
      allResults.totalMappings += fileResults.totalMappings
    }

    // Step 4: Generate overall report
    generateOverallReport(allResults, filesToTest)
  } catch (error) {
    console.error('âŒ Validation failed:', error.message)
    process.exit(1)
  }
}

async function findMappingFiles() {
  try {
    const files = await fs.readdir(MAPPINGS_DIR)
    return files.filter(
      file => file.includes('-mapping-') && file.endsWith('.json'),
    )
  } catch (error) {
    console.error(`âŒ Error reading mappings directory: ${error.message}`)
    return []
  }
}

function filterMappingFiles(allFiles, options) {
  let filesToTest = [...allFiles]

  // Filter by specific file (priority to variable)
  if (options.file) {
    const targetFile = options.file
    if (allFiles.includes(targetFile)) {
      return [targetFile]
    } else {
      console.log(`âš ï¸  File "${targetFile}" not found`)
      return []
    }
  }

  // Filter by product
  if (options.product) {
    filesToTest = filesToTest.filter(file =>
      file.startsWith(`${options.product}-mapping-`),
    )
  }

  // If not --all and no specific criteria, default to first file
  if (!options.all && !options.product && !options.file) {
    return filesToTest.slice(0, 1)
  }

  return filesToTest
}

async function validateSingleMappingFile(fileName, options) {
  const filePath = path.join(MAPPINGS_DIR, fileName)

  try {
    // Load mapping file
    const fileContent = await fs.readFile(filePath, 'utf8')
    const mappingData = JSON.parse(fileContent)

    // Extract URLs to test
    const urlsToTest = extractUrlsFromMapping(mappingData, options)

    console.log(
      `ğŸ“Š Loaded mapping file: ${
        Object.keys(mappingData).length
      } total entries`,
    )
    console.log(
      `ğŸ¯ Testing ${urlsToTest.length} URLs against ${LIVE_SITE_BASE}`,
    )
    console.log(
      `âš™ï¸  Sample size: ${options.sample}, Concurrent requests: ${CONCURRENT_REQUESTS}`,
    )

    // Test URLs in batches
    const results = await testUrlsInBatches(
      urlsToTest,
      CONCURRENT_REQUESTS,
      fileName,
      options,
    )

    // Generate file-specific report
    generateFileReport(
      results,
      fileName,
      urlsToTest.length,
      Object.keys(mappingData).length,
    )

    return {
      ...results,
      totalTested: urlsToTest.length,
      totalMappings: Object.keys(mappingData).length,
    }
  } catch (error) {
    console.error(`âŒ Error validating ${fileName}: ${error.message}`)
    return {
      success: [],
      failed: [],
      errors: [],
      totalTested: 0,
      totalMappings: 0,
    }
  }
}

function extractUrlsFromMapping(mappingData, options) {
  const urls = []

  // Extract all URLs from mapping (skip metadata entries)
  Object.entries(mappingData).forEach(([key, url]) => {
    if (key.startsWith('_')) return // Skip metadata

    urls.push({
      key,
      url,
      source: 'mapping',
    })
  })

  // Sample if not testing all
  if (!options.all && urls.length > options.sample) {
    // Shuffle and sample
    shuffleArray(urls)
    return urls.slice(0, options.sample)
  }

  return urls
}

async function testUrlsInBatches(urls, batchSize, fileName, options) {
  const results = {
    success: [],
    failed: [],
    errors: [],
  }

  console.log(`\nğŸ“¦ Testing ${urls.length} URLs in batches of ${batchSize}`)

  // Process URLs in batches
  for (let i = 0; i < urls.length; i += batchSize) {
    const batch = urls.slice(i, i + batchSize)

    console.log(
      `\nğŸ“¦ Batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(
        urls.length / batchSize,
      )} (${batch.length} URLs)`,
    )

    // Test batch concurrently
    const batchPromises = batch.map(urlInfo => testSingleUrl(urlInfo))
    const batchResults = await Promise.allSettled(batchPromises)

    // Process batch results
    batchResults.forEach((result, index) => {
      const urlInfo = batch[index]

      if (result.status === 'fulfilled') {
        const testResult = result.value

        if (testResult.success) {
          results.success.push({ ...urlInfo, ...testResult })
          console.log(`  âœ… ${testResult.status} ${urlInfo.url}`)
        } else {
          results.failed.push({ ...urlInfo, ...testResult })
          console.log(`  âŒ ${testResult.status} ${urlInfo.url}`)
          if (options.verbose) {
            console.log(`     Key: "${urlInfo.key}"`)
          }
        }
      } else {
        results.errors.push({ ...urlInfo, error: result.reason.message })
        console.log(`  ğŸ’¥ ERROR ${urlInfo.url} - ${result.reason.message}`)
      }
    })

    // Show progress
    const totalTested = i + batch.length
    const successRate = ((results.success.length / totalTested) * 100).toFixed(
      1,
    )
    console.log(
      `  ğŸ“Š Progress: ${totalTested}/${urls.length} (${successRate}% success)`,
    )

    // Brief pause between batches
    if (i + batchSize < urls.length) {
      await new Promise(resolve => setTimeout(resolve, 1000))
    }
  }

  return results
}

function testSingleUrl(urlInfo) {
  return new Promise(resolve => {
    const fullUrl = LIVE_SITE_BASE + urlInfo.url

    // Parse URL
    const urlObj = new URL(fullUrl)

    const options = {
      hostname: urlObj.hostname,
      port: urlObj.port || 443,
      path: urlObj.pathname + urlObj.search,
      method: 'HEAD',
      timeout: TIMEOUT_MS,
      headers: {
        'User-Agent': 'Mapping-URL-Validator/1.0 (docs validation script)',
      },
    }

    const req = https.request(options, res => {
      const success = res.statusCode >= 200 && res.statusCode < 400

      resolve({
        success,
        status: res.statusCode,
        fullUrl,
        redirected: res.statusCode >= 300 && res.statusCode < 400,
        location: res.headers.location || null,
      })
    })

    req.on('error', error => {
      resolve({
        success: false,
        status: 'ERROR',
        fullUrl,
        error: error.message,
      })
    })

    req.on('timeout', () => {
      req.destroy()
      resolve({
        success: false,
        status: 'TIMEOUT',
        fullUrl,
        error: `Request timed out after ${TIMEOUT_MS}ms`,
      })
    })

    req.end()
  })
}

function generateFileReport(results, fileName, totalTested, totalMappings) {
  const successCount = results.success.length
  const failedCount = results.failed.length
  const errorCount = results.errors.length
  const successRate = ((successCount / totalTested) * 100).toFixed(1)

  console.log(`\nğŸ“Š Results for ${fileName}:`)
  console.log(
    `   âœ… Successful: ${successCount}/${totalTested} (${successRate}%)`,
  )
  console.log(`   âŒ Failed: ${failedCount}/${totalTested}`)
  console.log(`   ğŸ’¥ Errors: ${errorCount}/${totalTested}`)
  console.log(`   ğŸ“„ Total mappings in file: ${totalMappings}`)

  // Show some failed URLs for debugging
  if (failedCount > 0) {
    console.log(`\nâŒ Failed URLs (first 5):`)
    results.failed.slice(0, 5).forEach(result => {
      console.log(`   ${result.status} ${result.fullUrl}`)
      console.log(`      Key: "${result.key}"`)
    })

    if (failedCount > 5) {
      console.log(`   ... and ${failedCount - 5} more`)
    }
  }
}

function generateOverallReport(allResults, filesToTest) {
  console.log('\n' + '='.repeat(80))
  console.log('ğŸ¯ OVERALL MAPPING VALIDATION REPORT')
  console.log('='.repeat(80))

  const successCount = allResults.success.length
  const failedCount = allResults.failed.length
  const errorCount = allResults.errors.length
  const totalTested = allResults.totalTested
  const successRate =
    totalTested > 0 ? ((successCount / totalTested) * 100).toFixed(1) : 0

  console.log(`ğŸ“Š Overall Results:`)
  console.log(
    `   âœ… Successful: ${successCount}/${totalTested} (${successRate}%)`,
  )
  console.log(`   âŒ Failed: ${failedCount}/${totalTested}`)
  console.log(`   ğŸ’¥ Errors: ${errorCount}/${totalTested}`)
  console.log(`   ğŸ“ Files tested: ${filesToTest.length}`)
  console.log(`   ğŸ“„ Total mappings: ${allResults.totalMappings}`)

  console.log(`\nğŸ’¡ Recommendations:`)
  if (successRate >= 90) {
    console.log(`   ğŸ‰ Excellent! Mapping URLs are working well`)
    console.log(
      `   âœ¨ ${successRate}% success rate indicates good URL generation`,
    )
  } else if (successRate >= 70) {
    console.log(`   âš ï¸  Good but some issues - check failed URLs`)
    console.log(
      `   ğŸ” ${failedCount} URLs failing, may need mapping adjustments`,
    )
  } else {
    console.log(`   ğŸ”§ Poor success rate suggests mapping issues`)
    console.log(`   ğŸ“‹ Check mapping generator URL logic`)
    console.log(`   ğŸ” Compare with working URLs from site`)
  }

  if (failedCount > 0) {
    console.log(`   ğŸ“ Common failure reasons:`)
    console.log(`      - Mapping file contains old/incorrect URLs`)
    console.log(`      - Files exist in repo but not deployed`)
    console.log(`      - URL generation logic differences`)
  }

  console.log(`\nğŸš€ To improve results:`)
  console.log(`   ğŸ“ Regenerate mappings: node mapping-generator.js`)
  console.log(`   ğŸ” Check specific file: Edit MAPPING_FILE_NAME variable`)
  console.log(
    `   ğŸ§ª Test with verbose: node validate-mapping-urls.js --verbose`,
  )

  console.log('\n' + '='.repeat(80))

  // Exit with error code if success rate is too low
  if (successRate < 50) {
    console.error('âŒ Success rate too low - likely mapping generation issues')
    process.exit(1)
  }
}

// Utility function to shuffle array
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1))
    ;[array[i], array[j]] = [array[j], array[i]]
  }
}

// Show usage if help requested
if (args.includes('--help') || args.includes('-h')) {
  console.log(`
ğŸ” Mapping URL Validator

EASY USAGE:
1. Edit MAPPING_FILE_NAME variable at top of file
2. Run: node validate-mapping-urls.js

COMMAND LINE USAGE:
node validate-mapping-urls.js                    # Test first mapping file found
node validate-mapping-urls.js --file=filename    # Test specific file  
node validate-mapping-urls.js --all              # Test all mapping files
node validate-mapping-urls.js --product=pro      # Test all pro mappings
node validate-mapping-urls.js --sample=50        # Test 50 random URLs

Options:
--file=NAME        Test specific mapping file
--all              Test all mapping files
--product=NAME     Test files for specific product
--sample=N         Test N random URLs (default: ${DEFAULT_SAMPLE_SIZE})
--verbose, -v      Show detailed output
--help, -h         Show this help

Examples:
node validate-mapping-urls.js --file=pro-mapping-8.0.json
node validate-mapping-urls.js --product=express --sample=100
node validate-mapping-urls.js --all --verbose

The validator tests complete URLs from mapping files against ${LIVE_SITE_BASE}
`)
  process.exit(0)
}

// Run the validator
if (require.main === module) {
  // Show which file will be tested at startup
  if (MAPPING_FILE_NAME) {
    console.log(`ğŸ“ Variable set: MAPPING_FILE_NAME = "${MAPPING_FILE_NAME}"`)
    console.log(
      `ğŸ’¡ To test different file, edit the variable at top of script\n`,
    )
  }

  validateMappingUrls().catch(error => {
    console.error('ğŸ’¥ Validation failed:', error.message)
    process.exit(1)
  })
}

module.exports = { validateMappingUrls }
